import * as client from "openid-client";
import { Strategy } from "openid-client/passport";
import passport from "passport";
import session from "express-session";
import { Request, Response, NextFunction, Application } from "express";
import memoize from "memoizee";
import connectPg from "connect-pg-simple";
import { storage } from "./storage.js";
import type { SessionUser, OAuthClaims } from "./express.d.ts";

function getClientId(): string {
  const replId = process.env.REPL_ID;
  if (!replId) {
    console.error('[Auth] REPL_ID is not set. Available env vars:', 
      Object.keys(process.env).filter(k => k.startsWith('REPL') || k.startsWith('REPLIT')).join(', '));
    throw new Error(
      'REPL_ID environment variable is required for OAuth authentication. ' +
      'This should be automatically set by Replit. If you see this error in production, ' +
      'ensure the deployment has access to Replit environment variables.'
    );
  }
  return replId;
}

const getOidcConfig = memoize(
  async () => {
    const clientId = getClientId();
    console.log(`[Auth] Initializing OIDC discovery with client_id: ${clientId.substring(0, 8)}...`);
    try {
      const config = await client.discovery(
        new URL(process.env.ISSUER_URL ?? "https://replit.com/oidc"),
        clientId
      );
      console.log('[Auth] OIDC discovery completed successfully');
      return config;
    } catch (error) {
      console.error('[Auth] OIDC discovery failed:', error);
      throw error;
    }
  },
  { maxAge: 3600 * 1000 }
);

// Shared frontend origin calculation
// This function determines the correct frontend origin for OAuth callbacks and CORS
// Follows Replit guidelines: use REPLIT_DEV_DOMAIN for dev, REPLIT_DOMAINS for production, FRONTEND_ORIGIN env var, or localhost:5000 fallback
export function getFrontendOrigin(): string {
  if (process.env.REPLIT_DEV_DOMAIN) {
    return `https://${process.env.REPLIT_DEV_DOMAIN}`;
  } else if (process.env.REPLIT_DOMAINS) {
    // REPLIT_DOMAINS is comma-separated in production (e.g., "sanchopoetry.com,www.sanchopoetry.com,...")
    // Use the first domain for OAuth callbacks
    const firstDomain = process.env.REPLIT_DOMAINS.split(',')[0].trim();
    return `https://${firstDomain}`;
  } else if (process.env.FRONTEND_ORIGIN) {
    return process.env.FRONTEND_ORIGIN;
  } else {
    return 'http://localhost:5000';
  }
}

export function getSession(): ReturnType<typeof session> {
  // Validate required environment variables
  if (!process.env.SESSION_SECRET) {
    throw new Error(
      'SESSION_SECRET must be set. This is auto-generated by Replit but must be configured for sessions to work.'
    );
  }

  // Validate session secret strength
  const sessionSecret = process.env.SESSION_SECRET;
  const minLength = 32;
  if (sessionSecret.length < minLength) {
    throw new Error(
      `SESSION_SECRET must be at least ${minLength} characters long for security. Current length: ${sessionSecret.length}`
    );
  }

  // Warn if session secret appears to be weak (only alphanumeric or only lowercase)
  const hasUpperCase = /[A-Z]/.test(sessionSecret);
  const hasLowerCase = /[a-z]/.test(sessionSecret);
  const hasNumbers = /[0-9]/.test(sessionSecret);
  const hasSpecialChars = /[^a-zA-Z0-9]/.test(sessionSecret);
  const characterTypeCount = [hasUpperCase, hasLowerCase, hasNumbers, hasSpecialChars].filter(Boolean).length;

  if (characterTypeCount < 3) {
    console.warn(
      'WARNING: SESSION_SECRET should contain at least 3 of: uppercase, lowercase, numbers, special characters for better security.'
    );
  }

  if (!process.env.DATABASE_URL) {
    throw new Error(
      'DATABASE_URL must be set. Sessions require a database connection.'
    );
  }

  const sessionTtl = 7 * 24 * 60 * 60 * 1000; // 1 week
  const pgStore = connectPg(session);
  const sessionStore = new pgStore({
    conString: process.env.DATABASE_URL,
    createTableIfMissing: true, // Auto-create sessions table if missing
    ttl: sessionTtl,
    tableName: "sessions",
  });
  
  // Detect production: either explicit NODE_ENV or Replit production deployment
  // In Replit production deployments: REPLIT_DOMAINS is set but REPLIT_DEV_DOMAIN is not
  const isReplitProduction = Boolean(process.env.REPLIT_DOMAINS && !process.env.REPLIT_DEV_DOMAIN);
  const isProduction = process.env.NODE_ENV === 'production' || isReplitProduction;
  
  // Extract cookie domain from custom domain or REPLIT_DOMAINS for cross-subdomain session sharing
  // This fixes mobile login issues where www.domain.com and domain.com don't share cookies
  let cookieDomain: string | undefined;
  const customDomain = process.env.CUSTOM_DOMAIN; // e.g., "sanchopoetry.com"
  if (customDomain) {
    // Prefix with dot for subdomain matching (e.g., ".sanchopoetry.com" matches www and apex)
    cookieDomain = customDomain.startsWith('.') ? customDomain : `.${customDomain}`;
  }
  
  console.log(`[Auth] Session configuration - isProduction: ${isProduction}, NODE_ENV: ${process.env.NODE_ENV}, REPLIT_DEV_DOMAIN: ${process.env.REPLIT_DEV_DOMAIN ? 'set' : 'not set'}, REPLIT_DOMAINS: ${process.env.REPLIT_DOMAINS ? 'set' : 'not set'}, cookieDomain: ${cookieDomain || 'default'}`);
  
  return session({
    secret: process.env.SESSION_SECRET,
    store: sessionStore,
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: true, // Always secure since Replit uses HTTPS
      sameSite: 'none', // Required for OAuth cross-origin redirects
      maxAge: sessionTtl,
      domain: cookieDomain, // Set domain for cross-subdomain session sharing (www vs apex)
    },
  });
}

function updateUserSession(user: SessionUser, tokens: client.TokenEndpointResponse): void {
  const getClaims = tokens.claims as (() => Record<string, unknown>) | undefined;
  const claims = (getClaims ? getClaims() : {}) as unknown as OAuthClaims;
  user.claims = claims;
  user.access_token = tokens.access_token;
  user.refresh_token = tokens.refresh_token;
  user.expires_at = claims?.exp;
}

async function upsertUser(claims: OAuthClaims): Promise<void> {
  await storage.upsertUser({
    id: claims.sub,
    email: claims.email,
    firstName: claims.first_name,
    lastName: claims.last_name,
    profileImageUrl: claims.profile_image_url,
  });
}

// Get the canonical hostname for OAuth - always use the primary domain
// This ensures OAuth callback URL is consistent regardless of www vs apex access
function getCanonicalHostname(requestHostname: string): string {
  // For local development, always use the request hostname
  // This handles localhost, 127.0.0.1, etc.
  if (requestHostname === 'localhost' || requestHostname.startsWith('127.') || requestHostname === '0.0.0.0') {
    return requestHostname;
  }
  
  // In production with custom domain, always use the canonical (apex) domain
  const customDomain = process.env.CUSTOM_DOMAIN;
  if (customDomain) {
    // Strip www prefix if present, use the apex domain
    return customDomain.replace(/^www\./, '');
  }
  
  // For Replit production domains (no dev domain means production)
  if (process.env.REPLIT_DOMAINS && !process.env.REPLIT_DEV_DOMAIN) {
    const primaryDomain = process.env.REPLIT_DOMAINS.split(',')[0].trim();
    if (primaryDomain) {
      return primaryDomain;
    }
  }
  
  // For dev environment with REPLIT_DEV_DOMAIN, use the request hostname
  // This allows the dev preview to work correctly
  if (process.env.REPLIT_DEV_DOMAIN) {
    return requestHostname;
  }
  
  // Fallback to request hostname
  return requestHostname;
}

export async function setupAuth(app: Application): Promise<void> {
  app.set("trust proxy", 1);
  app.use(getSession());
  app.use(passport.initialize());
  app.use(passport.session());

  const config = await getOidcConfig();

  const verify = async (tokens: client.TokenEndpointResponse, verified: (err: Error | null, user?: SessionUser) => void): Promise<void> => {
    try {
      console.log('[Auth] Verify callback started - processing tokens');
      const user: SessionUser = {};
      updateUserSession(user, tokens);
      const getClaims = tokens.claims as (() => Record<string, unknown>) | undefined;
      const claims = (getClaims ? getClaims() : {}) as unknown as OAuthClaims;
      console.log(`[Auth] Claims extracted - sub: ${claims?.sub || 'missing'}, email: ${claims?.email || 'missing'}`);
      
      await upsertUser(claims);
      console.log('[Auth] User upserted successfully');
      
      verified(null, user);
    } catch (error) {
      console.error('[Auth] Verify callback error:', error);
      verified(error as Error);
    }
  };

  // Keep track of registered strategies - we only need ONE strategy for the canonical domain
  const registeredStrategies = new Set<string>();

  // Helper function to ensure strategy exists for the canonical domain
  // IMPORTANT: Always uses the canonical domain to ensure OAuth callback URL matches
  // what's registered with Replit OAuth (only apex domain is whitelisted)
  const ensureStrategy = (requestHostname: string): string => {
    const canonicalHostname = getCanonicalHostname(requestHostname);
    const strategyName = `replitauth:${canonicalHostname}`;
    
    if (!registeredStrategies.has(strategyName)) {
      const callbackURL = `https://${canonicalHostname}/api/callback`;
      console.log(`[Auth] Registering OAuth strategy - canonical: ${canonicalHostname}, callback: ${callbackURL}, request was from: ${requestHostname}`);
      
      const strategy = new Strategy(
        {
          name: strategyName,
          config,
          scope: "openid email profile offline_access",
          callbackURL,
        },
        verify,
      );
      passport.use(strategy);
      registeredStrategies.add(strategyName);
    }
    
    return strategyName;
  };

  passport.serializeUser((user: Express.User, cb) => cb(null, user));
  passport.deserializeUser((user: Express.User, cb) => cb(null, user));

  app.get("/api/login", (req, res, next) => {
    const requestHostname = req.hostname;
    const canonicalHostname = getCanonicalHostname(requestHostname);
    const userAgent = req.get('user-agent') || 'unknown';
    const isMobile = /mobile|android|iphone|ipad/i.test(userAgent);
    console.log(`[Auth] Login initiated - request: ${requestHostname}, canonical: ${canonicalHostname}, mobile: ${isMobile}`);
    console.log(`[Auth] Session ID at login start: ${req.sessionID || 'none'}`);
    
    const strategyName = ensureStrategy(requestHostname);
    
    // Wrap the authenticate call to log cookie headers after redirect is set
    const originalRedirect = res.redirect.bind(res);
    res.redirect = ((statusOrUrl: number | string, url?: string) => {
      const setCookieHeader = res.getHeader('set-cookie');
      console.log(`[Auth] Redirect initiated with set-cookie header: ${setCookieHeader ? 'present' : 'MISSING'}`);
      if (setCookieHeader) {
        console.log(`[Auth] Cookie header value (first 100 chars): ${String(setCookieHeader).substring(0, 100)}...`);
      }
      if (typeof statusOrUrl === 'number') {
        return originalRedirect(statusOrUrl, url as string);
      }
      return originalRedirect(statusOrUrl);
    }) as typeof res.redirect;
    
    passport.authenticate(strategyName, {
      prompt: "login consent",
      scope: ["openid", "email", "profile", "offline_access"],
    })(req, res, next);
  });

  app.get("/api/callback", (req, res, next) => {
    const requestHostname = req.hostname;
    const canonicalHostname = getCanonicalHostname(requestHostname);
    const userAgent = req.get('user-agent') || 'unknown';
    const isMobile = /mobile|android|iphone|ipad/i.test(userAgent);
    console.log(`[Auth] Callback received - request: ${requestHostname}, canonical: ${canonicalHostname}, mobile: ${isMobile}`);
    console.log(`[Auth] Callback query params: code=${req.query.code ? 'present' : 'missing'}, state=${req.query.state ? 'present' : 'missing'}, error=${req.query.error || 'none'}`);
    console.log(`[Auth] Session ID: ${req.sessionID || 'none'}, session exists: ${!!req.session}`);
    console.log(`[Auth] Session data keys: ${req.session ? Object.keys(req.session).join(', ') : 'no session'}`);
    
    // Check if session cookie was sent - if not, state validation will fail
    const cookieHeader = req.headers.cookie;
    const hasSessionCookie = cookieHeader?.includes('connect.sid');
    console.log(`[Auth] Cookie header present: ${!!cookieHeader}, session cookie found: ${hasSessionCookie}`);
    
    if (!hasSessionCookie && req.query.state) {
      // Session cookie wasn't sent back - this will cause state mismatch
      console.error(`[Auth] CRITICAL: No session cookie on callback! Browser may be blocking cookies. User-Agent: ${userAgent}`);
      // Redirect with clear error message instead of letting it hang
      return res.redirect('/?login_error=cookies_blocked&message=Please+enable+cookies+and+try+again');
    }
    
    // Handle OAuth error responses from Replit
    if (req.query.error) {
      console.error(`[Auth] OAuth error from provider: ${req.query.error} - ${req.query.error_description || 'no description'}`);
      return res.redirect('/api/login?error=oauth_denied');
    }
    
    const strategyName = ensureStrategy(requestHostname);
    passport.authenticate(strategyName, (err: Error | null, user: Express.User | false, info: object | undefined) => {
      if (err) {
        console.error(`[Auth] Passport authentication error:`, err.message);
        console.error(`[Auth] Full error:`, err);
        return res.redirect('/api/login?error=auth_failed');
      }
      
      if (!user) {
        console.error(`[Auth] No user returned from authentication. Info:`, info);
        return res.redirect('/api/login?error=no_user');
      }
      
      // Manually log in the user
      req.logIn(user, (loginErr) => {
        if (loginErr) {
          console.error(`[Auth] Session login error:`, loginErr.message);
          return res.redirect('/api/login?error=session_failed');
        }
        
        console.log(`[Auth] Login successful for user, redirecting to /`);
        return res.redirect('/');
      });
    })(req, res, next);
  });

  app.get("/api/logout", (req, res) => {
    req.logout(() => {
      res.redirect(
        client.buildEndSessionUrl(config, {
          client_id: getClientId(),
          post_logout_redirect_uri: `${req.protocol}://${req.hostname}`,
        }).href
      );
    });
  });
}

export const isAuthenticated = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  const user = req.user;

  if (!req.isAuthenticated() || !user || !user.expires_at) {
    res.status(401).json({ 
      error: "Authentication required",
      message: "Please log in to continue",
      code: "NOT_AUTHENTICATED"
    });
    return;
  }

  const now = Math.floor(Date.now() / 1000);
  if (now <= user.expires_at) {
    next();
    return;
  }

  const refreshToken = user.refresh_token;
  if (!refreshToken) {
    res.status(401).json({ 
      error: "Session expired",
      message: "Your session has expired. Please log in again",
      code: "SESSION_EXPIRED"
    });
    return;
  }

  try {
    const config = await getOidcConfig();
    const tokenResponse = await client.refreshTokenGrant(config, refreshToken, {
      client_id: getClientId()
    });
    updateUserSession(user as SessionUser, tokenResponse);
    next();
    return;
  } catch (error) {
    const err = error as Error;
    console.error("Token refresh failed:", err.message);
    console.error("Token refresh error details:", error);
    res.status(401).json({ 
      error: "Session expired",
      message: "Your session has expired. Please log in again",
      code: "TOKEN_REFRESH_FAILED"
    });
    return;
  }
};
